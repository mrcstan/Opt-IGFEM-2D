%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Created by Marcus Tan on 10/22/2014
%%% Modified on 9/8/2015
%%% Copyright 2014 University of Illinois at Urbana-Champaign. All rights reserved
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% this function provides the objective function and also its gradient wrt
% design parameters if 'GradObj' is set to 'on' in the optimization options
% INPUT:
%   costFunction.type:
%       'DOMAIN_P_NORM_TEMP'
%       'VARIANCE'
%       'PRESSURE'
%   costFunction.area: area of domain (only valid if 
%                       costFunction.type == 'VARIANCE'
%   costFunction.objOpt: for mx_assemble_pseudo_adjoint_forces.cpp
%   costFunction.objOpt.normp: the p value in the p-norm
%   costFunction.objOpt.nDesignParams: number of design parameters
%   UUR: the solution at all nodes. this may also include Lagrange
%        multipliers at the end
%   UUR_update: the updated solution at all nodes, i.e., offset+backgroun
%               values. this may also include Lagrange multiplers at the
%               end
%   nLagrangeMult: number of Lagrange multipliers
%   if gradient is requested,
%       gauss:
%       KPP, KPF, KFP, KFF
%       fGloInd: logical indices of the free nodes and the Lagrange
%                multiplier
%       pGloInd: logical indices of the prescribed nodes
function [theta, gradTheta, oneNorm, gradOneNorm]...
    = objective_n_gradient(mesh, ...
                           channels, ...
                           costFunction, ...  
                           designParams, ...
                           UUR, ...
                           gauss, ...
                           supg, ...
                           Kff, ...
                           fGloInd, ...
                           calcGrad)

countTheta = 0;
nObjNodes = numel(costFunction.objOpt.node);
theta = nan(nObjNodes+1,1); 
if (calcGrad)
    [Fpseudo,Fadj,gradThetaRem,objVal,Fadj1norm,grad1normRem,oneNorm] ...
        = mx_assemble_pseudo_adjoint_forces(costFunction.objOpt,...
                                            mesh.node.coords',...
                                            mesh.elem.elem_node',...
                                            mesh.elem.heatSource,...
                                            mesh.convect,...
                                            gauss,...
                                            mesh.elem.parent,...
                                            channels,...
                                            mesh.elem.Neumann,...
                                            UUR, ...
                                            supg, ...
                                            true);
 
    gradTheta = nan(costFunction.objOpt.nDesignParams,nObjNodes+1);
    
    Fpseudof = Fpseudo(:,fGloInd);
    Lambdaf = Kff' \ Fadj(fGloInd); % column vector
    if costFunction.objOpt.calcOneNorm
        Lambda1normf = Kff' \ Fadj1norm(fGloInd); % column vector
        gradOneNorm = (Fpseudof*Lambda1normf + grad1normRem);
    else
        oneNorm =[];
        gradOneNorm = [];
    end
    switch costFunction.type
        case {'P_NORM','P_NORM_CHANNEL','P_NORM_CHANNEL_W_OFFSET'}
            countTheta = countTheta + 1;
            theta(countTheta) = objVal^(1./costFunction.objOpt.normp);
            gradTheta(:,countTheta) = (Fpseudof*Lambdaf + gradThetaRem)...
                        *theta/(objVal*costFunction.objOpt.normp);          
        case 'VARIANCE'
            countTheta = countTheta + 1;
            theta(countTheta) = objVal/costFunction.area - (oneNorm/costFunction.area)^2;
            gradTheta(:,countTheta) = (Fpseudof*Lambdaf + gradThetaRem)/costFunction.area ...
                            - 2/costFunction.area^2*oneNorm*gradOneNorm;
        case 'PRESSURE' 
            countTheta = countTheta + 1;
            totChanLen = sum(channels.length);
            TaveChan = objVal/totChanLen - mesh.convect.Toffset;
            [nu,DTnu] = kinematic_viscosity(channels.viscosity, ...
                                            channels.density, ...
                                            TaveChan,...
                                            channels.viscosityModel,...
                                            mesh.convect.Tunit);
            [pressure,~,~,~,~,~,DnuPressure] ...
                    = network_pressure_mass_flow_rate(channels.contvty,...
                                                      channels.nurbs,...
                                                      channels.diams,...
                                                      channels.heights,...
                                                      nu,...
                                                      channels.inletEndPoint,...
                                                      channels.massin,...
                                                      channels.powerXdensity,...
                                                      channels.pressureOutletEndPoint,...
                                                      channels.pressureOut,...
                                                      channels.crossSection);
            theta(countTheta) = pressure(channels.inletEndPoint) ...
                        -pressure(channels.pressureOutletEndPoint);
            D2Tave = (Fpseudof*Lambdaf + gradThetaRem)/totChanLen ...
                        - objVal/totChanLen^2*sum(channels.D2L,1)';
            % scale the gradient of pressure channels.D2P, 
            % which is evaluated at a reference viscosity and does not include
            % the effect of the change in viscosity with temperature
            gradTheta(:,countTheta) = DnuPressure(channels.inletEndPoint)*DTnu*...
                                D2Tave(1:costFunction.objOpt.nDesignParams)...
                                + nu/channels.viscosity*channels.D2P(channels.inletEndPoint,:)';  
        case 'PRESSURE_AVE_PANEL' 
            countTheta = countTheta + 1;
            Tave = objVal/costFunction.area - mesh.convect.Toffset;
            [nu,DTnu] = kinematic_viscosity(channels.viscosity, ...
                                            channels.density, ...
                                            Tave,...
                                            channels.viscosityModel,...
                                            mesh.convect.Tunit);
            [pressure,~,~,~,~,~,DnuPressure] ...
                    = network_pressure_mass_flow_rate(channels.contvty,...
                                                      channels.nurbs,...
                                                      channels.diams,...
                                                      channels.heights,...
                                                      nu,...
                                                      channels.inletEndPoint,...
                                                      channels.massin,...
                                                      channels.powerXdensity,...
                                                      channels.pressureOutletEndPoint,...
                                                      channels.pressureOut,...
                                                      channels.crossSection);
            theta(countTheta) = pressure(channels.inletEndPoint) ...
                        -pressure(channels.pressureOutletEndPoint);
            D2Tave = (Fpseudof*Lambdaf + gradThetaRem)/costFunction.area;
            % scale the gradient of pressure channels.D2P, 
            % which is evaluated at a reference viscosity and does not include
            % the effect of the change in viscosity with temperature
            gradTheta(:,countTheta) = DnuPressure(channels.inletEndPoint)*DTnu*...
                                D2Tave(1:costFunction.objOpt.nDesignParams)...
                                + nu/channels.viscosity*channels.D2P(channels.inletEndPoint,:)';                      
        case 'TPA'
            countTheta = countTheta + 1;
            theta(countTheta) = 0;
            gradTheta(:,countTheta) = zeros(costFunction.objOpt.nDesignParams,1);
            if costFunction.weights(1) > 0
                pnorm = objVal^(1./costFunction.objOpt.normp);
                gradpnorm = (Fpseudof*Lambdaf + gradThetaRem)...
                            *pnorm/(objVal*costFunction.objOpt.normp);
                theta(countTheta) = theta(countTheta) + costFunction.weights(1)*pnorm; 
                gradTheta(:,countTheta) = gradTheta(:,countTheta) + costFunction.weights(1)*gradpnorm;
            end
            if costFunction.weights(2) > 0
                Tave = oneNorm/costFunction.area;
                [nu,DTnu] = kinematic_viscosity(channels.viscosity, ...
                                                channels.density, ...
                                                Tave - mesh.convect.Toffset,...
                                                channels.viscosityModel,...
                                                mesh.convect.Tunit);
                [pressure,~,~,~,~,~,DnuPressure] ...
                        = network_pressure_mass_flow_rate(channels.contvty,...
                                                          channels.nurbs,...
                                                          channels.diams,...
                                                          channels.heights,...
                                                          nu,...
                                                          channels.inletEndPoint,...
                                                          channels.massin,...
                                                          channels.powerXdensity,...
                                                          channels.pressureOutletEndPoint,...
                                                          channels.pressureOut,...
                                                          channels.crossSection);
                delp = pressure(channels.inletEndPoint) ...
                            -pressure(channels.pressureOutletEndPoint);        
                D2Tave = gradOneNorm/costFunction.area;
                % scale the gradient of pressure channels.D2P, 
                % which is evaluated at a reference viscosity and does not include
                % the effect of the change in viscosity with temperature
                graddelp = DnuPressure(channels.inletEndPoint)*DTnu*...
                            D2Tave(1:costFunction.objOpt.nDesignParams)...
                            + nu/channels.viscosity*channels.D2P(channels.inletEndPoint,:)';
                theta(countTheta) = theta(countTheta) + costFunction.weights(2)*delp;
                gradTheta(:,countTheta) = gradTheta(:,countTheta) +costFunction.weights(2)*graddelp;         
            end 
            if costFunction.weights(3) > 0
                areaFrac = sum(channels.diams.*channels.length)/costFunction.area;
                [D2L, D2diam] = D2_channel_lengths_n_diameters(channels,designParams);
                gradAreaFrac = nan(designParams.nParams,1);
                for i = 1:designParams.nParams
                    gradAreaFrac(i) = sum(D2L(:,i).*channels.diams ...
                                 +channels.length.*D2diam(:,i))/costFunction.area;
                end 
                theta(countTheta) = theta(countTheta) + costFunction.weights(3)*areaFrac;
                gradTheta(:,countTheta) = gradTheta(:,countTheta) +costFunction.weights(3)*gradAreaFrac;
            end     
    end % end switch
    for i = 1:nObjNodes
        Fadj = zeros(size(Fadj));
        Fadj(costFunction.objOpt.node(i)) = 1.0;
        Lambdaf = Kff' \ Fadj(fGloInd); % column vector
        countTheta = countTheta + 1;
        gradTheta(:,countTheta) = Fpseudof*Lambdaf;
        theta(countTheta) = UUR(costFunction.objOpt.node(i));
    end
    gradTheta(:,countTheta+1:end) = [];
    theta(countTheta+1:end) = [];
else
    [~,~,~,objVal,~,~,oneNorm] ...
        = mx_assemble_pseudo_adjoint_forces(costFunction.objOpt,...
                                            mesh.node.coords',...
                                            mesh.elem.elem_node',...
                                            mesh.elem.heatSource,...
                                            mesh.convect,...
                                            gauss,...
                                            mesh.elem.parent,...
                                            channels,...
                                            mesh.elem.Neumann,...
                                            UUR, ...
                                            supg, ...
                                            false);                  
    switch costFunction.type
        case {'P_NORM','P_NORM_CHANNEL','P_NORM_CHANNEL_W_OFFSET'}
            countTheta = countTheta + 1;
            theta(countTheta) = objVal^(1./costFunction.objOpt.normp);
        case 'VARIANCE'
            countTheta = countTheta + 1;
            theta(countTheta) = objVal/costFunction.area - (oneNorm/costFunction.area)^2;
        case 'PRESSURE'           
            countTheta = countTheta + 1;
            totChanLen = sum(channels.length);
            TaveChan = objVal/totChanLen - mesh.convect.Toffset;
            nu = kinematic_viscosity(channels.viscosity,channels.density,...
                                    TaveChan, ...
                                    channels.viscosityModel,...
                                    mesh.convect.Tunit);
            pressure = network_pressure_mass_flow_rate(...
                                                channels.contvty,...
                                                channels.nurbs,...
                                                channels.diams,...
                                                channels.heights,...
                                                nu,...
                                                channels.inletEndPoint,...
                                                channels.massin,...
                                                channels.powerXdensity,...
                                                channels.pressureOutletEndPoint,...
                                                channels.pressureOut,...
                                                channels.crossSection);
                                
            theta(countTheta) = pressure(channels.inletEndPoint) ...
                        -pressure(channels.pressureOutletEndPoint);
         case 'PRESSURE_AVE_PANEL'           
            countTheta = countTheta + 1;
            Tave = objVal/costFunction.area - mesh.convect.Toffset;
            nu = kinematic_viscosity(channels.viscosity,channels.density,...
                                    Tave, ...
                                    channels.viscosityModel,...
                                    mesh.convect.Tunit);
            pressure = network_pressure_mass_flow_rate(...
                                                channels.contvty,...
                                                channels.nurbs,...
                                                channels.diams,...
                                                channels.heights,...
                                                nu,...
                                                channels.inletEndPoint,...
                                                channels.massin,...
                                                channels.powerXdensity,...
                                                channels.pressureOutletEndPoint,...
                                                channels.pressureOut,...
                                                channels.crossSection);
                                
            theta(countTheta) = pressure(channels.inletEndPoint) ...
                        -pressure(channels.pressureOutletEndPoint);            
        case 'TPA'
            countTheta = countTheta + 1;
            theta(countTheta) = 0;
            if costFunction.weights(1) > 0
                pnorm = objVal^(1./costFunction.objOpt.normp);
                theta(countTheta) = theta(countTheta) + costFunction.weights(1)*pnorm; 
            end
            if costFunction.weights(2) > 0
                Tave = oneNorm/costFunction.area;
                nu= kinematic_viscosity(channels.viscosity,channels.density,...
                                        Tave - mesh.convect.Toffset, ...
                                        channels.viscosityModel,...
                                        mesh.convect.Tunit);
                pressure = network_pressure_mass_flow_rate(channels.contvty,...
                                                          channels.nurbs,...
                                                          channels.diams,...
                                                          channels.heights,...
                                                          nu,...
                                                          channels.inletEndPoint,...
                                                          channels.massin,...
                                                          channels.powerXdensity,...
                                                          channels.pressureOutletEndPoint,...
                                                          channels.pressureOut,...
                                                          channels.crossSection);    
                delp = pressure(channels.inletEndPoint) ...
                            -pressure(channels.pressureOutletEndPoint);        
                theta(countTheta) = theta(countTheta) + costFunction.weights(2)*delp;      
            end 
            if costFunction.weights(3) > 0
                areaFrac = sum(channels.diams.*channels.length)/costFunction.area;      
                theta(countTheta) = theta(countTheta) + costFunction.weights(3)*areaFrac;
            end       
    end % end switch
    if nObjNodes > 0
        countTheta = countTheta+1;
        theta(countTheta:countTheta+nObjNodes-1) = UUR(costFunction.objOpt.node);
        countTheta = countTheta+nObjNodes-1;
    end
    theta(countTheta+1:end) = [];
    gradTheta =[];
    gradOneNorm = [];
end

end

