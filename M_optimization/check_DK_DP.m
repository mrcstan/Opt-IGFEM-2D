%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Created by Marcus Tan in 2014
%%% Modified on 9/8/2015
%%% Copyright 2014 University of Illinois at Urbana-Champaign. All rights reserved
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This function update the channels, perform finite element analysis and
% finaly provide all the needed data for sensitivity analysis

% INPUTS
%   delParams: change in design parameters
%              if this is empty, then channels are not updated
%   mesh: All the information about mesh and sensitivity analysis
%   channels: All the information about channels
%   iniChannels: Initial channel characteristics
%   femParams: Some miscellaneous variables needed in the code
%   sensitivity:
%   autoGrad:
%       1: auto-decide whether grad(s) need to be calculated based
%          on number of outputs, i.e, grad(s) are calculated only
%          when nargout == 2 or 4
%       2: calculate grad(s)
%       3: don't calculate grads
%   scaleObj:
%       true: scale objective function
%   updateGout:
%       true: update the global variable G_out
% OUTPUT:
function [Kall, Pall, UUR] = check_DK_DP(delParams,...
                                iniMesh, ...
                                iniChannels, ...
                                femParams,...
                                sensitivity, ...
                                calcGrad, ...
                                UUR)
global G_funcEvalCounter

mesh = iniMesh;

invalidChannels = false;
if ~isempty(delParams) 
    [channels,pressure,mass] = update_channels(delParams, ...
                                              sensitivity.designParams, ...
                                              sensitivity.restrictedParams, ...
                                              iniChannels, ...
                                              'add', ...
                                              calcGrad);
    if (any(isnan(pressure)))
        warning('some nodal pressures are NaN, returning NaN ...')
        invalidChannels = true;
    end                                  
else
    channels = iniChannels;
end
if (channels_self_intersections(channels,femParams.tol.channelSelfIntersect))
    warning('self-intersecting channels, returning NaN ...')
    invalidChannels = true;
end
if invalidChannels
    K = [];
    Pf = [];
    return
end

G_funcEvalCounter = G_funcEvalCounter+1;
fprintf('\n------------------------------------------------------------\n')
fprintf('function evaluation number %i ',G_funcEvalCounter)
fprintf('\n------------------------------------------------------------\n')

% IMPORTANT: Substitute all occurences of otherFlags.calcItrsectVel with
% calcGrad !
if (calcGrad)
    fprintf('checking for original nodes that are intersection points \n')
    fprintf('and kinks or branch points on element edges \n')
    %nodeTimer = tic;
    [mesh.node.coords, nodesMoved] ...
            = eliminate_original_node_intersections(mesh.node.coords,...
                                                    mesh.edge.edge_node,...   
                                                    channels.nurbs,...
                                                    channels.branch_kinks.XX',...
                                                    mesh.boundary,...
                                                    femParams.tol.boundary,...
                                                    femParams.tol.node,...
                                                    femParams.moveNode.maxAttempts,...
                                                    femParams.moveNode.dist,...
                                                    femParams.moveNode.randDirection);
    %IMPORTANT: at this point, if mesh.node.coords is changed, it will
    % no longer be consistent with mesh.DT.Points. 
    % So mesh.DT should be updated before being used
    % However, if refinement is requested, mesh.elem.elem_node will be
    % ordered in a certain way for the bisection method.
    % So before the refinement, do not change mesh.elem.elem_node                                            
    %toc(nodeTimer);
else
    nodesMoved = false;
end


fprintf('\nfinding intersection points \n')
%intersectTimer = tic;
[mesh.edge,...
 mesh.node,...
 mesh.elem,...
 channels.itrsectParams,...
 refineLevel]...
     =edges_curves_intersect(mesh.edge,mesh.node,...
                             mesh.elem,...
                             channels,...
                             femParams.tol,...
                             femParams.refine,...
                             calcGrad);                     
if refineLevel || nodesMoved
        % reconstruct DT if refinement has been carried out or
        % the nodes have been moved
        [mesh.DT,mesh.elem] ...
            = update_mesh_DT_n_elem(mesh.node.coords(1:mesh.node.nOriginalNode,:), ...
                                    mesh.edge.edge_node, ...
                                    mesh.elem);
        mesh.elem.elem_edge = find_elem_edge(mesh.elem.elem_node, ...
                                             mesh.edge.edge_node, ...
                                         mesh.node.nOriginalNode);  
elseif femParams.refine.maxRefineLevel
    % although no refinement has been carried out, elem_node has 
    % become inconsistent with DT after relabeling by the label
    % function for bisection. So, we need to 
    % revert it back to its original connectivity
    mesh.elem.elem_node = mesh.DT.ConnectivityList;
end
[mesh.elem.branch_kinks, ...
 mesh.node.coords, ...
 mesh.node.n_node, ...
 mesh.edge.itrsect] ...
            = elem_branching_n_kinks(mesh.DT,...
                                     mesh.elem.elem_edge,...
                                     mesh.edge.itrsect,...
                                     mesh.node.coords,...
                                     mesh.node.n_node,...
                                     channels.branch_kinks,...
                                     channels.itrsectParams,...
                                     femParams.tol.nurbsParam, ...
                                     femParams.tol.bary, ...
                                     channels.designParamNum, ...
                                     calcGrad);
% nOriginalEnrichNode only includes enrichment nodes that arise due to 
% the intersections
% If NURBS-IGFEM is used, additional enrichment nodes corresponding to
% additional control points may arise
mesh.node.nOriginalEnrichNode = mesh.node.n_node;

if (mesh.node.n_node == mesh.node.nOriginalNode)
    disp('conforming mesh')
else
    disp('nonconforming mesh')
end

fprintf('\nsetting boundary conditions \n')
[mesh.elem, mesh.node] = set_boundary_conditions(mesh.BCs,...
                                                 mesh.elem,...
                                                 mesh.node,...
                                                 mesh.boundary,...
                                                 femParams.tol.boundary);

% creat parent elements
disp('constructing parent elements')
%parentTimer = tic;
mesh.elem.parent = element_intersections(mesh.elem.elem_node, ...
                                         mesh.elem.dualedge, ...
                                         mesh.edge.edge_node, ...
                                         mesh.edge.itrsect, ...
                                         calcGrad);
%fprintf('\nparent time = %g \n', toc(parentTimer));


[mesh.elem.parent, ...
 mesh.elem.cstrElems, ...
 mesh.elem.nIGFEMelems] ...
                 = parent_elements_nurbs(mesh.elem.parent,...
                                         mesh.elem.elem_node,...
                                         mesh.elem.material,...
                                         mesh.material,...
                                         mesh.elem.branch_kinks,...
                                         mesh.node.coords,...
                                         mesh.node.nOriginalNode,...
                                         mesh.node.constraint,...
                                         channels,...
                                         femParams.tol.nurbsParam,...
                                         femParams.otherFlags.polyIGFEM,...
                                         calcGrad);                                        

%plot_mesh_nurbs_parent(mesh.node.coords,mesh.node.nOriginalNode,...
%                     mesh.elem.elem_node,mesh.elem.parent,channels,false,false);  

if(mesh.node.n_node==mesh.node.nOriginalNode)
    disp('conforming mesh')
else
    disp('non-conforming mesh')
    disp('constructing child elements')
    %childTimer = tic;
    [mesh.elem.parent,mesh.node]...edge, Dirichlet, nodeCoords, boundary
        =child_elements_nurbs(mesh.elem.parent,...
                              mesh.node,...
                              femParams.tol.collinear, ...
                              femParams.tol.slender,...
                              femParams.otherFlags.polyIGFEM);
    %fprintf('\nchild time = %g \n', toc(childTimer));                      
    % the global equation number of additional equations for 
    % Lagrange multiplier method                     
    for i = 1:numel(mesh.elem.cstrElems)
        mesh.elem.parent(mesh.elem.cstrElems(i)).cstrRows...
                =  mesh.elem.parent(mesh.elem.cstrElems(i)).cstrRows ...
                 + size(mesh.node.coords,1); 
    end                        

end

%%
%%%%%%%%%%%%%%%%%%%%%%%%%
%  Finite Element Code  %
%%%%%%%%%%%%%%%%%%%%%%%%%  
% gauss quadrature schemes

disp('performing FEM')
% eq_num:  Equation number assigned to each node
% n_dof: The number of degree of freedom in the model
 nLagrangeMult = numel(mesh.node.constraint.temp_node) ...
                    +size(mesh.node.constraint.nodePairs,1);
[n_dof, eq_num] = initialize(size(mesh.node.coords,1) + nLagrangeMult, ...
                             mesh.node.Dirichlet.n_pre_temp, ...
                             mesh.node.Dirichlet.temp_node);


[UUR, ~,fGloInd,~,Kff,Pf,Jac] = assemble_and_solve(mesh,...
                                                    eq_num,...
                                                    femParams.gauss,...
                                                    channels,...
                                                    femParams.otherFlags.supg,...
                                                    femParams.otherFlags.polyIGFEM,...
                                                    n_dof,...
                                                    calcGrad,...
                                                    UUR);

fprintf('\nsensitivity_analysis\n')
%sensitivityTimer = tic;
if mesh.convect.linearRad
    objective_n_gradient(mesh, ...
                          channels, ...
                          sensitivity.costFunction, ...
                          sensitivity.designParams, ...
                          UUR, ...
                          sensitivity.gauss, ...
                          femParams.otherFlags.supg, ...
                          Kff, ... 
                          fGloInd, ...
                          calcGrad);
else
    objective_n_gradient(mesh, ...
                          channels, ...
                          sensitivity.costFunction, ...
                          sensitivity.designParams, ...
                          UUR, ...
                          sensitivity.gauss, ...
                          femParams.otherFlags.supg, ...
                          Jac, ... 
                          fGloInd, ...
                          calcGrad);
end
nEqns = numel(eq_num);
Kall = nan(nEqns,nEqns);
Pall = nan(nEqns,1);
Kall(fGloInd,fGloInd) = Kff(eq_num(fGloInd),eq_num(fGloInd));
Pall(fGloInd) = Pf(eq_num(fGloInd));
end

